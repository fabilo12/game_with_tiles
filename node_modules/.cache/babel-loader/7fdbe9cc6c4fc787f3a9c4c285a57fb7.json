{"ast":null,"code":"import fillRepos from './fillRepos.js';\nimport calcPenalty from './calcPenalty.js';\nimport addArrays from '../js_utils/addArrays.js';\nexport default function finishRound(state) {\n  /* this function is called in putTilesIntoRow.js if all repos are empty*/\n  let newState = { ...state\n  };\n\n  if (isRoundOver) {\n    newState = evaluateRows(newState);\n    newState = evaluatePenalties(newState);\n    newState = fillRepos(newState);\n    newState = putBackStartingTile(newState);\n    const isGameOver = anyRowFull(newState);\n\n    if (isGameOver) {\n      newState = addFinalScore(newState);\n      newState.isGameOver = true;\n    }\n\n    return newState;\n  } else {\n    return state;\n  }\n}\n\nfunction evaluateRows(state) {\n  /*\n  for full rows, this function:\n  1) moves one tile per row to wall\n  2) updates scores based on added wall tiles\n  3) empties rows\n  */\n  let newState = { ...state\n  };\n\n  for (let player = 0; player < newState.rows.length; player++) {\n    for (let row = 0; row < newState.rows[player].length; row++) {\n      const rowColor = newState.rows[player][row][0];\n      const isRowFull = newState.rows[player][row].every(el => el === rowColor) && rowColor !== newState.emptyTileField;\n\n      if (isRowFull) {\n        const column = newState.wallPattern[row].findIndex(el => el === rowColor);\n        newState.wall[player][row][column] = rowColor;\n        const lastTile = [row, column];\n        newState = addScoreForLastTile(newState, player, lastTile);\n        newState = emptyRow(newState, player, row);\n      }\n    }\n  }\n\n  return newState;\n}\n\nfunction addScoreForLastTile(state, player, lastTile) {\n  const newState = { ...state\n  };\n  let scoreForLastTile = 1;\n  const directions = [[[1, 0], //vertical\n  [-1, 0] //vertical\n  ], [[0, 1], //horizontal\n  [0, -1] //horizontal\n  ]];\n\n  for (let d in directions) {\n    //vertically or horizontally\n    for (let delta of directions[d]) {\n      //up or down / left or right\n      let hasNeighbor = true;\n      let positionOnWall = lastTile;\n\n      while (hasNeighbor) {\n        positionOnWall = addArrays(positionOnWall, delta);\n        const row = positionOnWall[0];\n        const column = positionOnWall[1];\n        const isPosOnWall = row > -1 && column > -1 && row < state.nColor && column < state.nColor;\n\n        if (isPosOnWall) {\n          const isPosEmpty = newState.wall[player][row][column] === state.emptyTileField;\n\n          if (isPosEmpty) {\n            hasNeighbor = false;\n          } else {\n            scoreForLastTile++;\n          }\n        } else {\n          hasNeighbor = false;\n        }\n      }\n    }\n  }\n\n  newState.scores[player] += scoreForLastTile;\n  return newState;\n}\n\nfunction emptyRow(state, player, row) {\n  const newState = { ...state\n  };\n  const rowLength = row + 1;\n  const rowColor = newState.rows[player][row][0];\n  newState.usedTiles.push(...Array(rowLength - 1).fill(rowColor) //one tile is put on the wall\n  );\n  newState.rows[player][row] = Array(rowLength).fill(newState.emptyTileField);\n  return newState;\n}\n\nfunction evaluatePenalties(state) {\n  /*\n  this function:\n  1) updates scores based on penalties\n  2) moves penalty tiles to usedTiles\n  */\n  const newState = { ...state\n  };\n\n  for (let player in newState.penalties) {\n    const penalty = calcPenalty(newState, player);\n    newState.scores[player] -= penalty;\n    newState.scores[player] = Math.max( //negative score is not allowed\n    0, newState.scores[player]);\n    newState.usedTiles.push(...newState.penalties[player]);\n    newState.penalties[player] = [];\n  }\n\n  return newState;\n}\n\nfunction putBackStartingTile(state) {\n  const newState = { ...state\n  };\n  newState.startingTile = 'middle';\n  return newState;\n}\n\nfunction anyRowFull(state) {\n  let newState = { ...state\n  };\n  let isGameOver = false;\n\n  for (let player in newState.wall) {\n    for (let row in newState.wall[player]) {\n      const isRowFull = newState.wall[player][row].every(el => el !== newState.emptyTileField);\n\n      if (isRowFull) {\n        isGameOver = true;\n        return isGameOver;\n      }\n    }\n  }\n\n  return isGameOver;\n}\n\nfunction addFinalScore(state) {\n  const newState = { ...state\n  };\n\n  for (let player in newState.wall) {\n    let cumScore = 0;\n\n    for (let row in newState.wall[player]) {\n      const isRowFull = newState.wall[player][row].every(el => el !== newState.emptyTileField);\n\n      if (isRowFull) {\n        cumScore += 2;\n      }\n    }\n\n    for (let column in newState.wall[player]) {\n      const columnSum = newState.wall[player].reduce((acc, el) => acc + el[column], 0);\n      const isColumnFull = columnSum === 10;\n\n      if (isColumnFull) {\n        cumScore += 7;\n      }\n    }\n\n    for (let color in newState.wall[player]) {\n      const isColorFull = newState.wall[player].every(el => el.includes(color));\n\n      if (isColorFull) {\n        cumScore += 10;\n      }\n    }\n\n    newState.scores[player] += cumScore;\n  }\n\n  return newState;\n}\n/*function alertWinner(state) {\n\n    const newState = { ...state };\n\n    const maxScore = Math.max(...newState.scores);\n    \n    let winner = newState.playerList.filter(\n        (_,i) => newState.scores[i] === maxScore\n    );\n\n    if (winner.length===1) {\n        alert('The game is over and the winner is ' + winner + '.');\n    } else {\n        alert('The game is over and the winners are ' + winner.join(' and ') + '.');\n    }\n\n}*/","map":{"version":3,"names":["fillRepos","calcPenalty","addArrays","finishRound","state","newState","isRoundOver","evaluateRows","evaluatePenalties","putBackStartingTile","isGameOver","anyRowFull","addFinalScore","player","rows","length","row","rowColor","isRowFull","every","el","emptyTileField","column","wallPattern","findIndex","wall","lastTile","addScoreForLastTile","emptyRow","scoreForLastTile","directions","d","delta","hasNeighbor","positionOnWall","isPosOnWall","nColor","isPosEmpty","scores","rowLength","usedTiles","push","Array","fill","penalties","penalty","Math","max","startingTile","cumScore","columnSum","reduce","acc","isColumnFull","color","isColorFull","includes"],"sources":["/home/lorenz/programming/azul_create_react_app/src/azul_lib/finishRound.js"],"sourcesContent":["import fillRepos from './fillRepos.js';\nimport calcPenalty from './calcPenalty.js'\nimport addArrays from '../js_utils/addArrays.js'\n\nexport default function finishRound(state) {\n    /* this function is called in putTilesIntoRow.js if all repos are empty*/\n\t\n    let newState = { ...state };\n    \n\n    if (isRoundOver) {\n        newState = evaluateRows(newState);\n        newState = evaluatePenalties(newState);\n        newState = fillRepos(newState);\n        newState = putBackStartingTile(newState);\n        const isGameOver = anyRowFull(newState);\n        if (isGameOver) {\n            newState = addFinalScore(newState);\n            newState.isGameOver = true;\n        }\n        return newState\n    } else {\n        return state\n    }\n}\n\nfunction evaluateRows(state) {\n    /*\n    for full rows, this function:\n    1) moves one tile per row to wall\n    2) updates scores based on added wall tiles\n    3) empties rows\n    */\n\n\tlet newState = { ...state };\n\n    for (let player = 0; player < newState.rows.length; player++) {\n        for (let row = 0; row < newState.rows[player].length; row++) {\n            const rowColor = newState.rows[player][row][0];\n            const isRowFull = (\n                newState.rows[player][row].every(\n                    el => el===rowColor\n                ) && \n                rowColor!==newState.emptyTileField\n            );\n            if (isRowFull) {\n                const column = newState.wallPattern[row].findIndex(el => el===rowColor);\n                newState.wall[player][row][column] = rowColor;\n                const lastTile = [row, column];\n                newState = addScoreForLastTile(newState, player, lastTile);\n                newState = emptyRow(newState, player, row);\n            }\n        }\n    }\n\n\treturn newState\n}\n\nfunction addScoreForLastTile(state, player, lastTile) {\n\n\tconst newState = { ...state };\n\n    let scoreForLastTile = 1;\n\n    const directions = [\n        [\n            [1,0],//vertical\n            [-1,0]//vertical\n        ],\n        [\n            [0,1],//horizontal\n            [0,-1]//horizontal\n        ]\n    ];\n\n    for (let d in directions) {//vertically or horizontally\n        for (let delta of directions[d]) {//up or down / left or right\n            let hasNeighbor = true;\n            let positionOnWall = lastTile;\n            while (hasNeighbor) {\n                positionOnWall = addArrays(positionOnWall, delta);\n                const row = positionOnWall[0];\n                const column = positionOnWall[1];\n                const isPosOnWall = \n                    (row > -1) &&  \n                    (column > -1) && \n                    (row < state.nColor) && \n                    (column < state.nColor);\n                if(isPosOnWall) {\n                    const isPosEmpty = (newState.wall[player][row][column]===state.emptyTileField);\n                    if (isPosEmpty) {\n                        hasNeighbor = false;\n                    } else {\n                        scoreForLastTile++;\n                    }  \n                } else {\n                    hasNeighbor = false;\n                }\n            }\n        }\n    }\n    newState.scores[player] += scoreForLastTile;\n\n\treturn newState\n}\n\nfunction emptyRow(state, player, row) {\n\n\tconst newState = { ...state };\n\n    const rowLength = row + 1;\n    const rowColor = newState.rows[player][row][0];\n    newState.usedTiles.push(\n        ...Array(rowLength-1).fill(rowColor)//one tile is put on the wall\n    );\n\tnewState.rows[player][row] = Array(rowLength).fill(newState.emptyTileField);\n\n\treturn newState\n}\n\nfunction evaluatePenalties(state) {\n    /*\n    this function:\n    1) updates scores based on penalties\n    2) moves penalty tiles to usedTiles\n    */\n\n\tconst newState = { ...state };\n\n\tfor (let player in newState.penalties) {\n        \n        const penalty = calcPenalty(newState, player);\n        newState.scores[player] -= penalty;\n        newState.scores[player] = Math.max(//negative score is not allowed\n            0,\n            newState.scores[player]\n        );\n\n        newState.usedTiles.push(\n            ...newState.penalties[player]\n        );\n        newState.penalties[player] = [];\n    }\n\n\treturn newState\n}\n\nfunction putBackStartingTile(state) {\n\n\tconst newState = { ...state };\n\n\tnewState.startingTile = 'middle';\n\n\treturn newState\n}\n\nfunction anyRowFull(state) {\n   \n\tlet newState = { ...state };\n\n    let isGameOver = false;\n    for (let player in newState.wall) {\n        for (let row in newState.wall[player]) {\n            const isRowFull = newState.wall[player][row].every(\n                el => el !== newState.emptyTileField\n            );\n            if (isRowFull) {\n                isGameOver = true;\n                return isGameOver            \n            }\n        }\n    }\n\n\treturn isGameOver\n}\n\nfunction addFinalScore(state) {\n\n    const newState = { ...state };\n    \n    for (let player in newState.wall) {\n        let cumScore = 0;\n        for (let row in newState.wall[player]) {\n            const isRowFull = newState.wall[player][row].every(\n                el => el !== newState.emptyTileField\n            );\n            if (isRowFull) {\n                cumScore += 2;\n            }\n        }\n        for (let column in newState.wall[player]) {\n            const columnSum = newState.wall[player].reduce(\n                (acc,el) => acc + el[column],\n                0\n            );\n            const isColumnFull = (columnSum === 10);\n            if (isColumnFull) {\n                cumScore += 7;\n            }\n        }\n        for (let color in newState.wall[player]) {\n            const isColorFull = newState.wall[player].every(\n                el => el.includes(color)\n            );\n            if (isColorFull) {\n                cumScore += 10;\n            }\n        }\n        newState.scores[player] += cumScore;\n    }\n\n    return newState\n}\n\n/*function alertWinner(state) {\n\n    const newState = { ...state };\n\n    const maxScore = Math.max(...newState.scores);\n    \n    let winner = newState.playerList.filter(\n        (_,i) => newState.scores[i] === maxScore\n    );\n\n    if (winner.length===1) {\n        alert('The game is over and the winner is ' + winner + '.');\n    } else {\n        alert('The game is over and the winners are ' + winner.join(' and ') + '.');\n    }\n\n}*/"],"mappings":"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"},"metadata":{},"sourceType":"module"}