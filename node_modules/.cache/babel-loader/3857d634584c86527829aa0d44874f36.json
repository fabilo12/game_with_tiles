{"ast":null,"code":"import fillRepos from './fillRepos.js';\nimport calcPenalty from './calcPenalty.js';\nimport addArrays from '../js_utils/addArrays.js';\nexport default function finishRound(state) {\n  let newState = { ...state\n  };\n  const isRoundOver = newState.repos.every(el => el.every(el => el === newState.emptyTileField));\n\n  if (isRoundOver) {\n    newState = evaluateRows(newState);\n    newState = evaluatePenalties(newState);\n    newState = fillRepos(newState);\n    newState = putBackStartingTile(newState);\n    const isGameOver = anyRowFull(newState);\n\n    if (isGameOver) {\n      newState = addFinalScore(newState);\n      newState = alertWinner(newState);\n    }\n\n    return newState;\n  } else {\n    return state;\n  }\n}\n\nfunction evaluateRows(state) {\n  /*\n  for full rows, this function:\n  1) moves one tile per row to wall\n  2) updates scores based on added wall tiles\n  3) empties rows\n  */\n  let newState = { ...state\n  };\n\n  for (let player = 0; player < newState.rows.length; player++) {\n    for (let row = 0; row < newState.rows[player].length; row++) {\n      const rowColor = newState.rows[player][row][0];\n      const isRowFull = newState.rows[player][row].every(el => el === rowColor) && rowColor !== newState.emptyTileField;\n\n      if (isRowFull) {\n        const column = newState.wallPattern[row].findIndex(el => el === rowColor);\n        newState.wall[player][row][column] = rowColor;\n        const lastTile = [row, column];\n        newState = addScoreForLastTile(newState, player, lastTile);\n        newState = emptyRow(newState, player, row);\n      }\n    }\n  }\n\n  return newState;\n}\n\nfunction addScoreForLastTile(state, player, lastTile) {\n  const newState = { ...state\n  };\n  let scoreForLastTile = 1;\n  const directions = [[[1, 0], //vertical\n  [-1, 0] //vertical\n  ], [[0, 1], //horizontal\n  [0, -1] //horizontal\n  ]];\n\n  for (let d in directions) {\n    //vertically or horizontally\n    for (let delta of directions[d]) {\n      //up or down / left or right\n      let hasNeighbor = true;\n      let positionOnWall = lastTile;\n\n      while (hasNeighbor) {\n        positionOnWall = addArrays(positionOnWall, delta);\n        const row = positionOnWall[0];\n        const column = positionOnWall[1];\n        const isPosOnWall = row > -1 && column > -1 && row < state.nColor && column < state.nColor;\n\n        if (isPosOnWall) {\n          const isPosEmpty = newState.wall[player][row][column] === state.emptyTileField;\n\n          if (isPosEmpty) {\n            hasNeighbor = false;\n          } else {\n            scoreForLastTile++;\n          }\n        } else {\n          hasNeighbor = false;\n        }\n      }\n    }\n  }\n\n  newState.scores[player] += scoreForLastTile;\n  return newState;\n}\n\nfunction emptyRow(state, player, row) {\n  const newState = { ...state\n  };\n  const rowLength = row + 1;\n  const rowColor = newState.rows[player][row][0];\n  newState.usedTiles.push(...Array(rowLength - 1).fill(rowColor) //one tile is put on the wall\n  );\n  newState.rows[player][row] = Array(rowLength).fill(newState.emptyTileField);\n  return newState;\n}\n\nfunction evaluatePenalties(state) {\n  /*\n  this function:\n  1) updates scores based on penalties\n  2) moves penalty tiles to usedTiles\n  */\n  const newState = { ...state\n  };\n\n  for (let player in newState.penalties) {\n    const penalty = calcPenalty(newState, player);\n    newState.scores[player] -= penalty;\n    newState.scores[player] = Math.max( //negative score is not allowed\n    0, newState.scores[player]);\n    newState.usedTiles.push(...newState.penalties[player]);\n    newState.penalties[player] = [];\n  }\n\n  return newState;\n}\n\nfunction putBackStartingTile(state) {\n  const newState = { ...state\n  };\n  newState.startingTile = 'middle';\n  return newState;\n}\n\nfunction anyRowFull(state) {\n  let newState = { ...state\n  };\n  let isGameOver = false;\n\n  for (let player in newState.wall) {\n    for (let row in newState.wall[player]) {\n      const isRowFull = newState.wall[player][row].every(el => el !== newState.emptyTileField);\n\n      if (isRowFull) {\n        isGameOver = true;\n        return isGameOver;\n      }\n    }\n  }\n\n  return isGameOver;\n}\n\nfunction addFinalScore(state) {\n  const newState = { ...state\n  };\n\n  for (let player in newState.wall) {\n    let cumScore = 0;\n\n    for (let row in newState.wall[player]) {\n      const isRowFull = newState.wall[player][row].every(el => el !== newState.emptyTileField);\n\n      if (isRowFull) {\n        cumScore += 2;\n      }\n    }\n\n    for (let column in newState.wall[player]) {\n      const columnSum = newState.wall[player].reduce((acc, el) => acc + el[column], 0);\n      const isColumnFull = columnSum === 10;\n\n      if (isColumnFull) {\n        cumScore += 7;\n      }\n    }\n\n    for (let color in newState.wall[player]) {\n      const isColorFull = newState.wall[player].every(el => el.includes(color));\n\n      if (isColorFull) {\n        cumScore += 10;\n      }\n    }\n\n    newState.scores[player] += cumScore;\n  }\n\n  return newState;\n}\n\nfunction alertWinner(state) {\n  const newState = { ...state\n  };\n  const maxScore = Math.max(...newState.scores);\n  let winner = newState.playerList.filter((_, i) => newState.scores[i] === maxScore);\n\n  if (winner.length === 1) {\n    alert('The game is over and the winner is ' + winner + '.');\n  } else {\n    alert('The game is over and the winners are ' + winner.join(' and ') + '.');\n  }\n}","map":{"version":3,"names":["fillRepos","calcPenalty","addArrays","finishRound","state","newState","isRoundOver","repos","every","el","emptyTileField","evaluateRows","evaluatePenalties","putBackStartingTile","isGameOver","anyRowFull","addFinalScore","alertWinner","player","rows","length","row","rowColor","isRowFull","column","wallPattern","findIndex","wall","lastTile","addScoreForLastTile","emptyRow","scoreForLastTile","directions","d","delta","hasNeighbor","positionOnWall","isPosOnWall","nColor","isPosEmpty","scores","rowLength","usedTiles","push","Array","fill","penalties","penalty","Math","max","startingTile","cumScore","columnSum","reduce","acc","isColumnFull","color","isColorFull","includes","maxScore","winner","playerList","filter","_","i","alert","join"],"sources":["/home/lorenz/programming/azul_create_react_app/src/azul_lib/finishRound.js"],"sourcesContent":["import fillRepos from './fillRepos.js';\nimport calcPenalty from './calcPenalty.js'\nimport addArrays from '../js_utils/addArrays.js'\n\n\nexport default function finishRound(state) {\n\n\tlet newState = { ...state };\n\n    const isRoundOver = newState.repos.every(el => el.every(el => el===newState.emptyTileField));\n\n    if (isRoundOver) {\n        newState = evaluateRows(newState);\n        newState = evaluatePenalties(newState);\n        newState = fillRepos(newState);\n        newState = putBackStartingTile(newState);\n        const isGameOver = anyRowFull(newState);\n        if (isGameOver) {\n            newState = addFinalScore(newState);\n            newState = alertWinner(newState);\n        }\n        return newState\n    } else {\n        return state\n    }\n}\n\nfunction evaluateRows(state) {\n    /*\n    for full rows, this function:\n    1) moves one tile per row to wall\n    2) updates scores based on added wall tiles\n    3) empties rows\n    */\n\n\tlet newState = { ...state };\n\n    for (let player = 0; player < newState.rows.length; player++) {\n        for (let row = 0; row < newState.rows[player].length; row++) {\n            const rowColor = newState.rows[player][row][0];\n            const isRowFull = (\n                newState.rows[player][row].every(\n                    el => el===rowColor\n                ) && \n                rowColor!==newState.emptyTileField\n            );\n            if (isRowFull) {\n                const column = newState.wallPattern[row].findIndex(el => el===rowColor);\n                newState.wall[player][row][column] = rowColor;\n                const lastTile = [row, column];\n                newState = addScoreForLastTile(newState, player, lastTile);\n                newState = emptyRow(newState, player, row);\n            }\n        }\n    }\n\n\treturn newState\n}\n\nfunction addScoreForLastTile(state, player, lastTile) {\n\n\tconst newState = { ...state };\n\n    let scoreForLastTile = 1;\n\n    const directions = [\n        [\n            [1,0],//vertical\n            [-1,0]//vertical\n        ],\n        [\n            [0,1],//horizontal\n            [0,-1]//horizontal\n        ]\n    ];\n\n    for (let d in directions) {//vertically or horizontally\n        for (let delta of directions[d]) {//up or down / left or right\n            let hasNeighbor = true;\n            let positionOnWall = lastTile;\n            while (hasNeighbor) {\n                positionOnWall = addArrays(positionOnWall, delta);\n                const row = positionOnWall[0];\n                const column = positionOnWall[1];\n                const isPosOnWall = \n                    (row > -1) &&  \n                    (column > -1) && \n                    (row < state.nColor) && \n                    (column < state.nColor);\n                if(isPosOnWall) {\n                    const isPosEmpty = (newState.wall[player][row][column]===state.emptyTileField);\n                    if (isPosEmpty) {\n                        hasNeighbor = false;\n                    } else {\n                        scoreForLastTile++;\n                    }  \n                } else {\n                    hasNeighbor = false;\n                }\n            }\n        }\n    }\n    newState.scores[player] += scoreForLastTile;\n\n\treturn newState\n}\n\nfunction emptyRow(state, player, row) {\n\n\tconst newState = { ...state };\n\n    const rowLength = row + 1;\n    const rowColor = newState.rows[player][row][0];\n    newState.usedTiles.push(\n        ...Array(rowLength-1).fill(rowColor)//one tile is put on the wall\n    );\n\tnewState.rows[player][row] = Array(rowLength).fill(newState.emptyTileField);\n\n\treturn newState\n}\n\nfunction evaluatePenalties(state) {\n    /*\n    this function:\n    1) updates scores based on penalties\n    2) moves penalty tiles to usedTiles\n    */\n\n\tconst newState = { ...state };\n\n\tfor (let player in newState.penalties) {\n        \n        const penalty = calcPenalty(newState, player);\n        newState.scores[player] -= penalty;\n        newState.scores[player] = Math.max(//negative score is not allowed\n            0,\n            newState.scores[player]\n        );\n\n        newState.usedTiles.push(\n            ...newState.penalties[player]\n        );\n        newState.penalties[player] = [];\n    }\n\n\treturn newState\n}\n\nfunction putBackStartingTile(state) {\n\n\tconst newState = { ...state };\n\n\tnewState.startingTile = 'middle';\n\n\treturn newState\n}\n\nfunction anyRowFull(state) {\n   \n\tlet newState = { ...state };\n\n    let isGameOver = false;\n    for (let player in newState.wall) {\n        for (let row in newState.wall[player]) {\n            const isRowFull = newState.wall[player][row].every(\n                el => el !== newState.emptyTileField\n            );\n            if (isRowFull) {\n                isGameOver = true;\n                return isGameOver            \n            }\n        }\n    }\n\n\treturn isGameOver\n}\n\nfunction addFinalScore(state) {\n\n    const newState = { ...state };\n    \n    for (let player in newState.wall) {\n        let cumScore = 0;\n        for (let row in newState.wall[player]) {\n            const isRowFull = newState.wall[player][row].every(\n                el => el !== newState.emptyTileField\n            );\n            if (isRowFull) {\n                cumScore += 2;\n            }\n        }\n        for (let column in newState.wall[player]) {\n            const columnSum = newState.wall[player].reduce(\n                (acc,el) => acc + el[column],\n                0\n            );\n            const isColumnFull = (columnSum === 10);\n            if (isColumnFull) {\n                cumScore += 7;\n            }\n        }\n        for (let color in newState.wall[player]) {\n            const isColorFull = newState.wall[player].every(\n                el => el.includes(color)\n            );\n            if (isColorFull) {\n                cumScore += 10;\n            }\n        }\n        newState.scores[player] += cumScore;\n    }\n\n    return newState\n}\n\nfunction alertWinner(state) {\n\n    const newState = { ...state };\n\n    const maxScore = Math.max(...newState.scores);\n    \n    let winner = newState.playerList.filter(\n        (_,i) => newState.scores[i] === maxScore\n    );\n\n    if (winner.length===1) {\n        alert('The game is over and the winner is ' + winner + '.');\n    } else {\n        alert('The game is over and the winners are ' + winner.join(' and ') + '.');\n    }\n\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}