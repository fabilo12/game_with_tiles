{"ast":null,"code":"import fillRepos from './fillRepos.js';\nimport calcPenalty from './calcPenalty.js';\nimport addArrays from '../js_utils/addArrays.js';\nexport default function finishRound(state) {\n  let newState = { ...state\n  };\n  const isRoundOver = newState.repos.every(el => el.every(el => el === newState.emptyTileField));\n\n  if (isRoundOver) {\n    newState = evaluateRows(newState);\n    newState = evaluatePenalties(newState);\n    newState = fillRepos(newState);\n    newState = putBackStartingTile(newState);\n    const isGameOver = anyRowFull(newState);\n\n    if (isGameOver) {\n      newState = addFinalScore(newState);\n      newState.isGameOver = true;\n    }\n\n    return newState;\n  } else {\n    return state;\n  }\n}\n\nfunction evaluateRows(state) {\n  /*\n  for full rows, this function:\n  1) moves one tile per row to wall\n  2) updates scores based on added wall tiles\n  3) empties rows\n  */\n  let newState = { ...state\n  };\n\n  for (let player = 0; player < newState.rows.length; player++) {\n    for (let row = 0; row < newState.rows[player].length; row++) {\n      const rowColor = newState.rows[player][row][0];\n      const isRowFull = newState.rows[player][row].every(el => el === rowColor) && rowColor !== newState.emptyTileField;\n\n      if (isRowFull) {\n        const column = newState.wallPattern[row].findIndex(el => el === rowColor);\n        newState.wall[player][row][column] = rowColor;\n        const lastTile = [row, column];\n        newState = addScoreForLastTile(newState, player, lastTile);\n        newState = emptyRow(newState, player, row);\n      }\n    }\n  }\n\n  return newState;\n}\n\nfunction addScoreForLastTile(state, player, lastTile) {\n  const newState = { ...state\n  };\n  let scoreForLastTile = 1;\n  const directions = [[[1, 0], //vertical\n  [-1, 0] //vertical\n  ], [[0, 1], //horizontal\n  [0, -1] //horizontal\n  ]];\n\n  for (let d in directions) {\n    //vertically or horizontally\n    for (let delta of directions[d]) {\n      //up or down / left or right\n      let hasNeighbor = true;\n      let positionOnWall = lastTile;\n\n      while (hasNeighbor) {\n        positionOnWall = addArrays(positionOnWall, delta);\n        const row = positionOnWall[0];\n        const column = positionOnWall[1];\n        const isPosOnWall = row > -1 && column > -1 && row < state.nColor && column < state.nColor;\n\n        if (isPosOnWall) {\n          const isPosEmpty = newState.wall[player][row][column] === state.emptyTileField;\n\n          if (isPosEmpty) {\n            hasNeighbor = false;\n          } else {\n            scoreForLastTile++;\n          }\n        } else {\n          hasNeighbor = false;\n        }\n      }\n    }\n  }\n\n  newState.scores[player] += scoreForLastTile;\n  return newState;\n}\n\nfunction emptyRow(state, player, row) {\n  const newState = { ...state\n  };\n  const rowLength = row + 1;\n  const rowColor = newState.rows[player][row][0];\n  newState.usedTiles.push(...Array(rowLength - 1).fill(rowColor) //one tile is put on the wall\n  );\n  newState.rows[player][row] = Array(rowLength).fill(newState.emptyTileField);\n  return newState;\n}\n\nfunction evaluatePenalties(state) {\n  /*\n  this function:\n  1) updates scores based on penalties\n  2) moves penalty tiles to usedTiles\n  */\n  const newState = { ...state\n  };\n\n  for (let player in newState.penalties) {\n    const penalty = calcPenalty(newState, player);\n    newState.scores[player] -= penalty;\n    newState.scores[player] = Math.max( //negative score is not allowed\n    0, newState.scores[player]);\n    newState.usedTiles.push(...newState.penalties[player]);\n    newState.penalties[player] = [];\n  }\n\n  return newState;\n}\n\nfunction putBackStartingTile(state) {\n  const newState = { ...state\n  };\n  newState.startingTile = 'middle';\n  return newState;\n}\n\nfunction anyRowFull(state) {\n  let newState = { ...state\n  };\n  let isGameOver = false;\n\n  for (let player in newState.wall) {\n    for (let row in newState.wall[player]) {\n      const isRowFull = newState.wall[player][row].every(el => el !== newState.emptyTileField);\n\n      if (isRowFull) {\n        isGameOver = true;\n        return isGameOver;\n      }\n    }\n  }\n\n  return isGameOver;\n}\n\nfunction addFinalScore(state) {\n  const newState = { ...state\n  };\n\n  for (let player in newState.wall) {\n    let cumScore = 0;\n\n    for (let row in newState.wall[player]) {\n      const isRowFull = newState.wall[player][row].every(el => el !== newState.emptyTileField);\n\n      if (isRowFull) {\n        cumScore += 2;\n      }\n    }\n\n    for (let column in newState.wall[player]) {\n      const columnSum = newState.wall[player].reduce((acc, el) => acc + el[column], 0);\n      const isColumnFull = columnSum === 10;\n\n      if (isColumnFull) {\n        cumScore += 7;\n      }\n    }\n\n    for (let color in newState.wall[player]) {\n      const isColorFull = newState.wall[player].every(el => el.includes(color));\n\n      if (isColorFull) {\n        cumScore += 10;\n      }\n    }\n\n    newState.scores[player] += cumScore;\n  }\n\n  return newState;\n}\n/*function alertWinner(state) {\n\n    const newState = { ...state };\n\n    const maxScore = Math.max(...newState.scores);\n    \n    let winner = newState.playerList.filter(\n        (_,i) => newState.scores[i] === maxScore\n    );\n\n    if (winner.length===1) {\n        alert('The game is over and the winner is ' + winner + '.');\n    } else {\n        alert('The game is over and the winners are ' + winner.join(' and ') + '.');\n    }\n\n}*/","map":{"version":3,"names":["fillRepos","calcPenalty","addArrays","finishRound","state","newState","isRoundOver","repos","every","el","emptyTileField","evaluateRows","evaluatePenalties","putBackStartingTile","isGameOver","anyRowFull","addFinalScore","player","rows","length","row","rowColor","isRowFull","column","wallPattern","findIndex","wall","lastTile","addScoreForLastTile","emptyRow","scoreForLastTile","directions","d","delta","hasNeighbor","positionOnWall","isPosOnWall","nColor","isPosEmpty","scores","rowLength","usedTiles","push","Array","fill","penalties","penalty","Math","max","startingTile","cumScore","columnSum","reduce","acc","isColumnFull","color","isColorFull","includes"],"sources":["/home/lorenz/programming/azul_create_react_app/src/azul_lib/finishRound.js"],"sourcesContent":["import fillRepos from './fillRepos.js';\nimport calcPenalty from './calcPenalty.js'\nimport addArrays from '../js_utils/addArrays.js'\n\n\nexport default function finishRound(state) {\n\n\tlet newState = { ...state };\n\n    const isRoundOver = newState.repos.every(\n        el => el.every(el => el===newState.emptyTileField)\n    );\n\n    if (isRoundOver) {\n        newState = evaluateRows(newState);\n        newState = evaluatePenalties(newState);\n        newState = fillRepos(newState);\n        newState = putBackStartingTile(newState);\n        const isGameOver = anyRowFull(newState);\n        if (isGameOver) {\n            newState = addFinalScore(newState);\n            newState.isGameOver = true;\n        }\n        return newState\n    } else {\n        return state\n    }\n}\n\nfunction evaluateRows(state) {\n    /*\n    for full rows, this function:\n    1) moves one tile per row to wall\n    2) updates scores based on added wall tiles\n    3) empties rows\n    */\n\n\tlet newState = { ...state };\n\n    for (let player = 0; player < newState.rows.length; player++) {\n        for (let row = 0; row < newState.rows[player].length; row++) {\n            const rowColor = newState.rows[player][row][0];\n            const isRowFull = (\n                newState.rows[player][row].every(\n                    el => el===rowColor\n                ) && \n                rowColor!==newState.emptyTileField\n            );\n            if (isRowFull) {\n                const column = newState.wallPattern[row].findIndex(el => el===rowColor);\n                newState.wall[player][row][column] = rowColor;\n                const lastTile = [row, column];\n                newState = addScoreForLastTile(newState, player, lastTile);\n                newState = emptyRow(newState, player, row);\n            }\n        }\n    }\n\n\treturn newState\n}\n\nfunction addScoreForLastTile(state, player, lastTile) {\n\n\tconst newState = { ...state };\n\n    let scoreForLastTile = 1;\n\n    const directions = [\n        [\n            [1,0],//vertical\n            [-1,0]//vertical\n        ],\n        [\n            [0,1],//horizontal\n            [0,-1]//horizontal\n        ]\n    ];\n\n    for (let d in directions) {//vertically or horizontally\n        for (let delta of directions[d]) {//up or down / left or right\n            let hasNeighbor = true;\n            let positionOnWall = lastTile;\n            while (hasNeighbor) {\n                positionOnWall = addArrays(positionOnWall, delta);\n                const row = positionOnWall[0];\n                const column = positionOnWall[1];\n                const isPosOnWall = \n                    (row > -1) &&  \n                    (column > -1) && \n                    (row < state.nColor) && \n                    (column < state.nColor);\n                if(isPosOnWall) {\n                    const isPosEmpty = (newState.wall[player][row][column]===state.emptyTileField);\n                    if (isPosEmpty) {\n                        hasNeighbor = false;\n                    } else {\n                        scoreForLastTile++;\n                    }  \n                } else {\n                    hasNeighbor = false;\n                }\n            }\n        }\n    }\n    newState.scores[player] += scoreForLastTile;\n\n\treturn newState\n}\n\nfunction emptyRow(state, player, row) {\n\n\tconst newState = { ...state };\n\n    const rowLength = row + 1;\n    const rowColor = newState.rows[player][row][0];\n    newState.usedTiles.push(\n        ...Array(rowLength-1).fill(rowColor)//one tile is put on the wall\n    );\n\tnewState.rows[player][row] = Array(rowLength).fill(newState.emptyTileField);\n\n\treturn newState\n}\n\nfunction evaluatePenalties(state) {\n    /*\n    this function:\n    1) updates scores based on penalties\n    2) moves penalty tiles to usedTiles\n    */\n\n\tconst newState = { ...state };\n\n\tfor (let player in newState.penalties) {\n        \n        const penalty = calcPenalty(newState, player);\n        newState.scores[player] -= penalty;\n        newState.scores[player] = Math.max(//negative score is not allowed\n            0,\n            newState.scores[player]\n        );\n\n        newState.usedTiles.push(\n            ...newState.penalties[player]\n        );\n        newState.penalties[player] = [];\n    }\n\n\treturn newState\n}\n\nfunction putBackStartingTile(state) {\n\n\tconst newState = { ...state };\n\n\tnewState.startingTile = 'middle';\n\n\treturn newState\n}\n\nfunction anyRowFull(state) {\n   \n\tlet newState = { ...state };\n\n    let isGameOver = false;\n    for (let player in newState.wall) {\n        for (let row in newState.wall[player]) {\n            const isRowFull = newState.wall[player][row].every(\n                el => el !== newState.emptyTileField\n            );\n            if (isRowFull) {\n                isGameOver = true;\n                return isGameOver            \n            }\n        }\n    }\n\n\treturn isGameOver\n}\n\nfunction addFinalScore(state) {\n\n    const newState = { ...state };\n    \n    for (let player in newState.wall) {\n        let cumScore = 0;\n        for (let row in newState.wall[player]) {\n            const isRowFull = newState.wall[player][row].every(\n                el => el !== newState.emptyTileField\n            );\n            if (isRowFull) {\n                cumScore += 2;\n            }\n        }\n        for (let column in newState.wall[player]) {\n            const columnSum = newState.wall[player].reduce(\n                (acc,el) => acc + el[column],\n                0\n            );\n            const isColumnFull = (columnSum === 10);\n            if (isColumnFull) {\n                cumScore += 7;\n            }\n        }\n        for (let color in newState.wall[player]) {\n            const isColorFull = newState.wall[player].every(\n                el => el.includes(color)\n            );\n            if (isColorFull) {\n                cumScore += 10;\n            }\n        }\n        newState.scores[player] += cumScore;\n    }\n\n    return newState\n}\n\n/*function alertWinner(state) {\n\n    const newState = { ...state };\n\n    const maxScore = Math.max(...newState.scores);\n    \n    let winner = newState.playerList.filter(\n        (_,i) => newState.scores[i] === maxScore\n    );\n\n    if (winner.length===1) {\n        alert('The game is over and the winner is ' + winner + '.');\n    } else {\n        alert('The game is over and the winners are ' + winner.join(' and ') + '.');\n    }\n\n}*/"],"mappings":"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"},"metadata":{},"sourceType":"module"}