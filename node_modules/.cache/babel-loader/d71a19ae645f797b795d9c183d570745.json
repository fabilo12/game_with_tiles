{"ast":null,"code":"import fillRepos from './fillRepos.js';\nimport calcPenalty from './calcPenalty.js';\nimport addArrays from '../js_utils/addArrays.js';\nexport default function finishRound(state) {\n  /* this function is called in putTilesIntoRow.js if all repos are empty*/\n  let newState = { ...state\n  };\n  newState = evaluateRows(newState);\n  newState = evaluatePenalties(newState);\n  const isGameOver = anyRowFull(newState);\n\n  if (isGameOver) {\n    newState = addFinalScore(newState);\n    newState.isGameOver = true;\n  } else {\n    newState = fillRepos(newState);\n    newState = putBackStartingTile(newState);\n  }\n\n  return newState;\n}\n\nfunction evaluateRows(state) {\n  /*\n  for full rows, this function:\n  1) moves one tile per row to wall\n  2) updates scores based on added wall tiles\n  3) empties rows\n  */\n  let newState = { ...state\n  };\n\n  for (let player = 0; player < newState.rows.length; player++) {\n    for (let row = 0; row < newState.rows[player].length; row++) {\n      const rowColor = newState.rows[player][row][0];\n      const isRowFull = newState.rows[player][row].every(el => el === rowColor) && rowColor !== newState.emptyTileField;\n\n      if (isRowFull) {\n        const column = newState.wallPattern[row].findIndex(el => el === rowColor);\n        newState.wall[player][row][column] = rowColor;\n        const lastTile = [row, column];\n        newState = addScoreForLastTile(newState, player, lastTile);\n        newState = emptyRow(newState, player, row);\n      }\n    }\n  }\n\n  return newState;\n}\n\nfunction addScoreForLastTile(state, player, lastTile) {\n  const newState = { ...state\n  };\n  let scoreForLastTile = 1;\n  const directions = [[[1, 0], //vertical\n  [-1, 0] //vertical\n  ], [[0, 1], //horizontal\n  [0, -1] //horizontal\n  ]];\n\n  for (let d in directions) {\n    //vertically or horizontally\n    for (let delta of directions[d]) {\n      //up or down / left or right\n      let hasNeighbor = true;\n      let positionOnWall = lastTile;\n\n      while (hasNeighbor) {\n        positionOnWall = addArrays(positionOnWall, delta);\n        const row = positionOnWall[0];\n        const column = positionOnWall[1];\n        const isPosOnWall = row > -1 && column > -1 && row < state.nColor && column < state.nColor;\n\n        if (isPosOnWall) {\n          const isPosEmpty = newState.wall[player][row][column] === state.emptyTileField;\n\n          if (isPosEmpty) {\n            hasNeighbor = false;\n          } else {\n            scoreForLastTile++;\n          }\n        } else {\n          hasNeighbor = false;\n        }\n      }\n    }\n  }\n\n  newState.scores[player] += scoreForLastTile;\n  return newState;\n}\n\nfunction emptyRow(state, player, row) {\n  const newState = { ...state\n  };\n  const rowLength = row + 1;\n  const rowColor = newState.rows[player][row][0];\n  newState.usedTiles.push(...Array(rowLength - 1).fill(rowColor) //one tile is put on the wall\n  );\n  newState.rows[player][row] = Array(rowLength).fill(newState.emptyTileField);\n  return newState;\n}\n\nfunction evaluatePenalties(state) {\n  /*\n  this function:\n  1) updates scores based on penalties\n  2) moves penalty tiles to usedTiles\n  */\n  const newState = { ...state\n  };\n\n  for (let player in newState.penalties) {\n    const penalty = calcPenalty(newState, player);\n    newState.scores[player] -= penalty;\n    newState.scores[player] = Math.max( //negative score is not allowed\n    0, newState.scores[player]);\n    newState.usedTiles.push(...newState.penalties[player]);\n    newState.penalties[player] = [];\n  }\n\n  return newState;\n}\n\nfunction putBackStartingTile(state) {\n  const newState = { ...state\n  };\n  newState.startingTile = 'middle';\n  return newState;\n}\n\nfunction anyRowFull(state) {\n  let newState = { ...state\n  };\n  let isGameOver = false;\n\n  for (let player in newState.wall) {\n    for (let row in newState.wall[player]) {\n      const isRowFull = newState.wall[player][row].every(el => el !== newState.emptyTileField);\n\n      if (isRowFull) {\n        isGameOver = true;\n        return isGameOver;\n      }\n    }\n  }\n\n  return isGameOver;\n}\n\nfunction addFinalScore(state) {\n  const newState = { ...state\n  };\n\n  for (let player in newState.wall) {\n    let cumScore = 0;\n\n    for (let row in newState.wall[player]) {\n      const isRowFull = newState.wall[player][row].every(el => el !== newState.emptyTileField);\n\n      if (isRowFull) {\n        cumScore += 2;\n      }\n    }\n\n    for (let column in newState.wall[player]) {\n      const columnSum = newState.wall[player].reduce((acc, el) => acc + el[column], 0);\n      const isColumnFull = columnSum === 10;\n\n      if (isColumnFull) {\n        cumScore += 7;\n      }\n    }\n\n    for (let color in newState.wall[player]) {\n      const isColorFull = newState.wall[player].every(el => el.includes(color));\n\n      if (isColorFull) {\n        cumScore += 10;\n      }\n    }\n\n    newState.scores[player] += cumScore;\n  }\n\n  return newState;\n}","map":{"version":3,"names":["fillRepos","calcPenalty","addArrays","finishRound","state","newState","evaluateRows","evaluatePenalties","isGameOver","anyRowFull","addFinalScore","putBackStartingTile","player","rows","length","row","rowColor","isRowFull","every","el","emptyTileField","column","wallPattern","findIndex","wall","lastTile","addScoreForLastTile","emptyRow","scoreForLastTile","directions","d","delta","hasNeighbor","positionOnWall","isPosOnWall","nColor","isPosEmpty","scores","rowLength","usedTiles","push","Array","fill","penalties","penalty","Math","max","startingTile","cumScore","columnSum","reduce","acc","isColumnFull","color","isColorFull","includes"],"sources":["/home/lorenz/programming/azul_create_react_app/src/azul_lib/finishRound.js"],"sourcesContent":["import fillRepos from './fillRepos.js';\nimport calcPenalty from './calcPenalty.js'\nimport addArrays from '../js_utils/addArrays.js'\n\nexport default function finishRound(state) {\n    /* this function is called in putTilesIntoRow.js if all repos are empty*/\n\t\n    let newState = { ...state };\n\n    newState = evaluateRows(newState);\n    newState = evaluatePenalties(newState);\n    const isGameOver = anyRowFull(newState);\n    if (isGameOver) {\n        newState = addFinalScore(newState);\n        newState.isGameOver = true;\n    } else {\n        newState = fillRepos(newState);\n        newState = putBackStartingTile(newState);\n    }\n    \n    return newState\n}\n\nfunction evaluateRows(state) {\n    /*\n    for full rows, this function:\n    1) moves one tile per row to wall\n    2) updates scores based on added wall tiles\n    3) empties rows\n    */\n\n\tlet newState = { ...state };\n\n    for (let player = 0; player < newState.rows.length; player++) {\n        for (let row = 0; row < newState.rows[player].length; row++) {\n            const rowColor = newState.rows[player][row][0];\n            const isRowFull = (\n                newState.rows[player][row].every(\n                    el => el===rowColor\n                ) && \n                rowColor!==newState.emptyTileField\n            );\n            if (isRowFull) {\n                const column = newState.wallPattern[row].findIndex(el => el===rowColor);\n                newState.wall[player][row][column] = rowColor;\n                const lastTile = [row, column];\n                newState = addScoreForLastTile(newState, player, lastTile);\n                newState = emptyRow(newState, player, row);\n            }\n        }\n    }\n\n\treturn newState\n}\n\nfunction addScoreForLastTile(state, player, lastTile) {\n\n\tconst newState = { ...state };\n\n    let scoreForLastTile = 1;\n\n    const directions = [\n        [\n            [1,0],//vertical\n            [-1,0]//vertical\n        ],\n        [\n            [0,1],//horizontal\n            [0,-1]//horizontal\n        ]\n    ];\n\n    for (let d in directions) {//vertically or horizontally\n        for (let delta of directions[d]) {//up or down / left or right\n            let hasNeighbor = true;\n            let positionOnWall = lastTile;\n            while (hasNeighbor) {\n                positionOnWall = addArrays(positionOnWall, delta);\n                const row = positionOnWall[0];\n                const column = positionOnWall[1];\n                const isPosOnWall = \n                    (row > -1) &&  \n                    (column > -1) && \n                    (row < state.nColor) && \n                    (column < state.nColor);\n                if(isPosOnWall) {\n                    const isPosEmpty = (newState.wall[player][row][column]===state.emptyTileField);\n                    if (isPosEmpty) {\n                        hasNeighbor = false;\n                    } else {\n                        scoreForLastTile++;\n                    }  \n                } else {\n                    hasNeighbor = false;\n                }\n            }\n        }\n    }\n    newState.scores[player] += scoreForLastTile;\n\n\treturn newState\n}\n\nfunction emptyRow(state, player, row) {\n\n\tconst newState = { ...state };\n\n    const rowLength = row + 1;\n    const rowColor = newState.rows[player][row][0];\n    newState.usedTiles.push(\n        ...Array(rowLength-1).fill(rowColor)//one tile is put on the wall\n    );\n\tnewState.rows[player][row] = Array(rowLength).fill(newState.emptyTileField);\n\n\treturn newState\n}\n\nfunction evaluatePenalties(state) {\n    /*\n    this function:\n    1) updates scores based on penalties\n    2) moves penalty tiles to usedTiles\n    */\n\n\tconst newState = { ...state };\n\n\tfor (let player in newState.penalties) {\n        \n        const penalty = calcPenalty(newState, player);\n        newState.scores[player] -= penalty;\n        newState.scores[player] = Math.max(//negative score is not allowed\n            0,\n            newState.scores[player]\n        );\n\n        newState.usedTiles.push(\n            ...newState.penalties[player]\n        );\n        newState.penalties[player] = [];\n    }\n\n\treturn newState\n}\n\nfunction putBackStartingTile(state) {\n\n\tconst newState = { ...state };\n\n\tnewState.startingTile = 'middle';\n\n\treturn newState\n}\n\nfunction anyRowFull(state) {\n   \n\tlet newState = { ...state };\n\n    let isGameOver = false;\n    for (let player in newState.wall) {\n        for (let row in newState.wall[player]) {\n            const isRowFull = newState.wall[player][row].every(\n                el => el !== newState.emptyTileField\n            );\n            if (isRowFull) {\n                isGameOver = true;\n                return isGameOver            \n            }\n        }\n    }\n\n\treturn isGameOver\n}\n\nfunction addFinalScore(state) {\n\n    const newState = { ...state };\n    \n    for (let player in newState.wall) {\n        let cumScore = 0;\n        for (let row in newState.wall[player]) {\n            const isRowFull = newState.wall[player][row].every(\n                el => el !== newState.emptyTileField\n            );\n            if (isRowFull) {\n                cumScore += 2;\n            }\n        }\n        for (let column in newState.wall[player]) {\n            const columnSum = newState.wall[player].reduce(\n                (acc,el) => acc + el[column],\n                0\n            );\n            const isColumnFull = (columnSum === 10);\n            if (isColumnFull) {\n                cumScore += 7;\n            }\n        }\n        for (let color in newState.wall[player]) {\n            const isColorFull = newState.wall[player].every(\n                el => el.includes(color)\n            );\n            if (isColorFull) {\n                cumScore += 10;\n            }\n        }\n        newState.scores[player] += cumScore;\n    }\n\n    return newState\n}\n"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,gBAAtB;AACA,OAAOC,WAAP,MAAwB,kBAAxB;AACA,OAAOC,SAAP,MAAsB,0BAAtB;AAEA,eAAe,SAASC,WAAT,CAAqBC,KAArB,EAA4B;EACvC;EAEA,IAAIC,QAAQ,GAAG,EAAE,GAAGD;EAAL,CAAf;EAEAC,QAAQ,GAAGC,YAAY,CAACD,QAAD,CAAvB;EACAA,QAAQ,GAAGE,iBAAiB,CAACF,QAAD,CAA5B;EACA,MAAMG,UAAU,GAAGC,UAAU,CAACJ,QAAD,CAA7B;;EACA,IAAIG,UAAJ,EAAgB;IACZH,QAAQ,GAAGK,aAAa,CAACL,QAAD,CAAxB;IACAA,QAAQ,CAACG,UAAT,GAAsB,IAAtB;EACH,CAHD,MAGO;IACHH,QAAQ,GAAGL,SAAS,CAACK,QAAD,CAApB;IACAA,QAAQ,GAAGM,mBAAmB,CAACN,QAAD,CAA9B;EACH;;EAED,OAAOA,QAAP;AACH;;AAED,SAASC,YAAT,CAAsBF,KAAtB,EAA6B;EACzB;AACJ;AACA;AACA;AACA;AACA;EAEC,IAAIC,QAAQ,GAAG,EAAE,GAAGD;EAAL,CAAf;;EAEG,KAAK,IAAIQ,MAAM,GAAG,CAAlB,EAAqBA,MAAM,GAAGP,QAAQ,CAACQ,IAAT,CAAcC,MAA5C,EAAoDF,MAAM,EAA1D,EAA8D;IAC1D,KAAK,IAAIG,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGV,QAAQ,CAACQ,IAAT,CAAcD,MAAd,EAAsBE,MAA9C,EAAsDC,GAAG,EAAzD,EAA6D;MACzD,MAAMC,QAAQ,GAAGX,QAAQ,CAACQ,IAAT,CAAcD,MAAd,EAAsBG,GAAtB,EAA2B,CAA3B,CAAjB;MACA,MAAME,SAAS,GACXZ,QAAQ,CAACQ,IAAT,CAAcD,MAAd,EAAsBG,GAAtB,EAA2BG,KAA3B,CACIC,EAAE,IAAIA,EAAE,KAAGH,QADf,KAGAA,QAAQ,KAAGX,QAAQ,CAACe,cAJxB;;MAMA,IAAIH,SAAJ,EAAe;QACX,MAAMI,MAAM,GAAGhB,QAAQ,CAACiB,WAAT,CAAqBP,GAArB,EAA0BQ,SAA1B,CAAoCJ,EAAE,IAAIA,EAAE,KAAGH,QAA/C,CAAf;QACAX,QAAQ,CAACmB,IAAT,CAAcZ,MAAd,EAAsBG,GAAtB,EAA2BM,MAA3B,IAAqCL,QAArC;QACA,MAAMS,QAAQ,GAAG,CAACV,GAAD,EAAMM,MAAN,CAAjB;QACAhB,QAAQ,GAAGqB,mBAAmB,CAACrB,QAAD,EAAWO,MAAX,EAAmBa,QAAnB,CAA9B;QACApB,QAAQ,GAAGsB,QAAQ,CAACtB,QAAD,EAAWO,MAAX,EAAmBG,GAAnB,CAAnB;MACH;IACJ;EACJ;;EAEJ,OAAOV,QAAP;AACA;;AAED,SAASqB,mBAAT,CAA6BtB,KAA7B,EAAoCQ,MAApC,EAA4Ca,QAA5C,EAAsD;EAErD,MAAMpB,QAAQ,GAAG,EAAE,GAAGD;EAAL,CAAjB;EAEG,IAAIwB,gBAAgB,GAAG,CAAvB;EAEA,MAAMC,UAAU,GAAG,CACf,CACI,CAAC,CAAD,EAAG,CAAH,CADJ,EACU;EACN,CAAC,CAAC,CAAF,EAAI,CAAJ,CAFJ,CAEU;EAFV,CADe,EAKf,CACI,CAAC,CAAD,EAAG,CAAH,CADJ,EACU;EACN,CAAC,CAAD,EAAG,CAAC,CAAJ,CAFJ,CAEU;EAFV,CALe,CAAnB;;EAWA,KAAK,IAAIC,CAAT,IAAcD,UAAd,EAA0B;IAAC;IACvB,KAAK,IAAIE,KAAT,IAAkBF,UAAU,CAACC,CAAD,CAA5B,EAAiC;MAAC;MAC9B,IAAIE,WAAW,GAAG,IAAlB;MACA,IAAIC,cAAc,GAAGR,QAArB;;MACA,OAAOO,WAAP,EAAoB;QAChBC,cAAc,GAAG/B,SAAS,CAAC+B,cAAD,EAAiBF,KAAjB,CAA1B;QACA,MAAMhB,GAAG,GAAGkB,cAAc,CAAC,CAAD,CAA1B;QACA,MAAMZ,MAAM,GAAGY,cAAc,CAAC,CAAD,CAA7B;QACA,MAAMC,WAAW,GACZnB,GAAG,GAAG,CAAC,CAAR,IACCM,MAAM,GAAG,CAAC,CADX,IAECN,GAAG,GAAGX,KAAK,CAAC+B,MAFb,IAGCd,MAAM,GAAGjB,KAAK,CAAC+B,MAJpB;;QAKA,IAAGD,WAAH,EAAgB;UACZ,MAAME,UAAU,GAAI/B,QAAQ,CAACmB,IAAT,CAAcZ,MAAd,EAAsBG,GAAtB,EAA2BM,MAA3B,MAAqCjB,KAAK,CAACgB,cAA/D;;UACA,IAAIgB,UAAJ,EAAgB;YACZJ,WAAW,GAAG,KAAd;UACH,CAFD,MAEO;YACHJ,gBAAgB;UACnB;QACJ,CAPD,MAOO;UACHI,WAAW,GAAG,KAAd;QACH;MACJ;IACJ;EACJ;;EACD3B,QAAQ,CAACgC,MAAT,CAAgBzB,MAAhB,KAA2BgB,gBAA3B;EAEH,OAAOvB,QAAP;AACA;;AAED,SAASsB,QAAT,CAAkBvB,KAAlB,EAAyBQ,MAAzB,EAAiCG,GAAjC,EAAsC;EAErC,MAAMV,QAAQ,GAAG,EAAE,GAAGD;EAAL,CAAjB;EAEG,MAAMkC,SAAS,GAAGvB,GAAG,GAAG,CAAxB;EACA,MAAMC,QAAQ,GAAGX,QAAQ,CAACQ,IAAT,CAAcD,MAAd,EAAsBG,GAAtB,EAA2B,CAA3B,CAAjB;EACAV,QAAQ,CAACkC,SAAT,CAAmBC,IAAnB,CACI,GAAGC,KAAK,CAACH,SAAS,GAAC,CAAX,CAAL,CAAmBI,IAAnB,CAAwB1B,QAAxB,CADP,CACwC;EADxC;EAGHX,QAAQ,CAACQ,IAAT,CAAcD,MAAd,EAAsBG,GAAtB,IAA6B0B,KAAK,CAACH,SAAD,CAAL,CAAiBI,IAAjB,CAAsBrC,QAAQ,CAACe,cAA/B,CAA7B;EAEA,OAAOf,QAAP;AACA;;AAED,SAASE,iBAAT,CAA2BH,KAA3B,EAAkC;EAC9B;AACJ;AACA;AACA;AACA;EAEC,MAAMC,QAAQ,GAAG,EAAE,GAAGD;EAAL,CAAjB;;EAEA,KAAK,IAAIQ,MAAT,IAAmBP,QAAQ,CAACsC,SAA5B,EAAuC;IAEhC,MAAMC,OAAO,GAAG3C,WAAW,CAACI,QAAD,EAAWO,MAAX,CAA3B;IACAP,QAAQ,CAACgC,MAAT,CAAgBzB,MAAhB,KAA2BgC,OAA3B;IACAvC,QAAQ,CAACgC,MAAT,CAAgBzB,MAAhB,IAA0BiC,IAAI,CAACC,GAAL,EAAS;IAC/B,CADsB,EAEtBzC,QAAQ,CAACgC,MAAT,CAAgBzB,MAAhB,CAFsB,CAA1B;IAKAP,QAAQ,CAACkC,SAAT,CAAmBC,IAAnB,CACI,GAAGnC,QAAQ,CAACsC,SAAT,CAAmB/B,MAAnB,CADP;IAGAP,QAAQ,CAACsC,SAAT,CAAmB/B,MAAnB,IAA6B,EAA7B;EACH;;EAEJ,OAAOP,QAAP;AACA;;AAED,SAASM,mBAAT,CAA6BP,KAA7B,EAAoC;EAEnC,MAAMC,QAAQ,GAAG,EAAE,GAAGD;EAAL,CAAjB;EAEAC,QAAQ,CAAC0C,YAAT,GAAwB,QAAxB;EAEA,OAAO1C,QAAP;AACA;;AAED,SAASI,UAAT,CAAoBL,KAApB,EAA2B;EAE1B,IAAIC,QAAQ,GAAG,EAAE,GAAGD;EAAL,CAAf;EAEG,IAAII,UAAU,GAAG,KAAjB;;EACA,KAAK,IAAII,MAAT,IAAmBP,QAAQ,CAACmB,IAA5B,EAAkC;IAC9B,KAAK,IAAIT,GAAT,IAAgBV,QAAQ,CAACmB,IAAT,CAAcZ,MAAd,CAAhB,EAAuC;MACnC,MAAMK,SAAS,GAAGZ,QAAQ,CAACmB,IAAT,CAAcZ,MAAd,EAAsBG,GAAtB,EAA2BG,KAA3B,CACdC,EAAE,IAAIA,EAAE,KAAKd,QAAQ,CAACe,cADR,CAAlB;;MAGA,IAAIH,SAAJ,EAAe;QACXT,UAAU,GAAG,IAAb;QACA,OAAOA,UAAP;MACH;IACJ;EACJ;;EAEJ,OAAOA,UAAP;AACA;;AAED,SAASE,aAAT,CAAuBN,KAAvB,EAA8B;EAE1B,MAAMC,QAAQ,GAAG,EAAE,GAAGD;EAAL,CAAjB;;EAEA,KAAK,IAAIQ,MAAT,IAAmBP,QAAQ,CAACmB,IAA5B,EAAkC;IAC9B,IAAIwB,QAAQ,GAAG,CAAf;;IACA,KAAK,IAAIjC,GAAT,IAAgBV,QAAQ,CAACmB,IAAT,CAAcZ,MAAd,CAAhB,EAAuC;MACnC,MAAMK,SAAS,GAAGZ,QAAQ,CAACmB,IAAT,CAAcZ,MAAd,EAAsBG,GAAtB,EAA2BG,KAA3B,CACdC,EAAE,IAAIA,EAAE,KAAKd,QAAQ,CAACe,cADR,CAAlB;;MAGA,IAAIH,SAAJ,EAAe;QACX+B,QAAQ,IAAI,CAAZ;MACH;IACJ;;IACD,KAAK,IAAI3B,MAAT,IAAmBhB,QAAQ,CAACmB,IAAT,CAAcZ,MAAd,CAAnB,EAA0C;MACtC,MAAMqC,SAAS,GAAG5C,QAAQ,CAACmB,IAAT,CAAcZ,MAAd,EAAsBsC,MAAtB,CACd,CAACC,GAAD,EAAKhC,EAAL,KAAYgC,GAAG,GAAGhC,EAAE,CAACE,MAAD,CADN,EAEd,CAFc,CAAlB;MAIA,MAAM+B,YAAY,GAAIH,SAAS,KAAK,EAApC;;MACA,IAAIG,YAAJ,EAAkB;QACdJ,QAAQ,IAAI,CAAZ;MACH;IACJ;;IACD,KAAK,IAAIK,KAAT,IAAkBhD,QAAQ,CAACmB,IAAT,CAAcZ,MAAd,CAAlB,EAAyC;MACrC,MAAM0C,WAAW,GAAGjD,QAAQ,CAACmB,IAAT,CAAcZ,MAAd,EAAsBM,KAAtB,CAChBC,EAAE,IAAIA,EAAE,CAACoC,QAAH,CAAYF,KAAZ,CADU,CAApB;;MAGA,IAAIC,WAAJ,EAAiB;QACbN,QAAQ,IAAI,EAAZ;MACH;IACJ;;IACD3C,QAAQ,CAACgC,MAAT,CAAgBzB,MAAhB,KAA2BoC,QAA3B;EACH;;EAED,OAAO3C,QAAP;AACH"},"metadata":{},"sourceType":"module"}