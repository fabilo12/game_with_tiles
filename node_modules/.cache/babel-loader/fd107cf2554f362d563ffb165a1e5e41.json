{"ast":null,"code":"import fillRepos from './fillRepos.js';\nimport calcPenalty from './calcPenalty.js';\nimport addArrays from '../js_utils/addArrays.js';\nexport default function finishRound(state) {\n  let newState = { ...state\n  };\n  const isRoundOver = newState.repos.every(el => el.every(el => el === newState.emptyTileField));\n\n  if (isRoundOver) {\n    newState = evaluateRows(newState);\n    newState = evaluatePenalties(newState);\n    newState = fillRepos(newState);\n    newState = putBackStartingTile(newState);\n    newState = calcFinalScores(newState);\n    return newState;\n  } else {\n    return state;\n  }\n}\n\nfunction evaluateRows(state) {\n  /*\n  for full rows, this function:\n  1) moves one tile per row to wall\n  2) updates scores based on added wall tiles\n  3) empties rows\n  */\n  let newState = { ...state\n  };\n\n  for (let player = 0; player < newState.rows.length; player++) {\n    for (let row = 0; row < newState.rows[player].length; row++) {\n      const rowColor = newState.rows[player][row][0];\n      const isRowFull = newState.rows[player][row].every(el => el === rowColor) && rowColor !== newState.emptyTileField;\n\n      if (isRowFull) {\n        const column = newState.wallPattern[row].findIndex(el => el === rowColor);\n        newState.wall[player][row][column] = rowColor;\n        const lastTile = [row, column];\n        newState = addScoreForLastTile(newState, player, lastTile);\n        newState = emptyRow(newState, player, row);\n      }\n    }\n  }\n\n  return newState;\n}\n\nfunction addScoreForLastTile(state, player, lastTile) {\n  const newState = { ...state\n  };\n  let scoreForLastTile = 1;\n  const directions = [[[1, 0], //vertical\n  [-1, 0] //vertical\n  ], [[0, 1], //horizontal\n  [0, -1] //horizontal\n  ]];\n\n  for (let d in directions) {\n    //vertically or horizontally\n    for (let delta of directions[d]) {\n      //up or down / left or right\n      let hasNeighbor = true;\n      let positionOnWall = lastTile;\n\n      while (hasNeighbor) {\n        positionOnWall = addArrays(positionOnWall, delta);\n        const row = positionOnWall[0];\n        const column = positionOnWall[1];\n        const isPosOnWall = row > -1 && column > -1 && row < state.nColor && column < state.nColor;\n\n        if (isPosOnWall) {\n          const isPosEmpty = newState.wall[player][row][column] === state.emptyTileField;\n\n          if (isPosEmpty) {\n            hasNeighbor = false;\n          } else {\n            scoreForLastTile++;\n          }\n        } else {\n          hasNeighbor = false;\n        }\n      }\n    }\n  }\n\n  newState.scores[player] += scoreForLastTile;\n  return newState;\n}\n\nfunction emptyRow(state, player, row) {\n  const newState = { ...state\n  };\n  const rowLength = row + 1;\n  const rowColor = newState.rows[player][row][0];\n  newState.usedTiles.push(...Array(rowLength - 1).fill(rowColor) //one tile is put on the wall\n  );\n  newState.rows[player][row] = Array(rowLength).fill(newState.emptyTileField);\n  return newState;\n}\n\nfunction evaluatePenalties(state) {\n  /*\n  this function:\n  1) updates scores based on penalties\n  2) moves penalty tiles to usedTiles\n  */\n  const newState = { ...state\n  };\n\n  for (let player in newState.penalties) {\n    const penalty = calcPenalty(newState, player);\n    newState.scores[player] -= penalty;\n    newState.scores[player] = Math.max( //negative score is not allowed\n    0, newState.scores[player]);\n    newState.usedTiles.push(...newState.penalties[player]);\n    newState.penalties[player] = [];\n  }\n\n  return newState;\n}\n\nfunction putBackStartingTile(state) {\n  const newState = { ...state\n  };\n  newState.startingTile = 'middle';\n  return newState;\n}\n\nfunction calcFinalScores(state) {\n  const newState = { ...state\n  }; //any player with full row? then calc final score and make alert for winner\n\n  const isGameOver = false;\n\n  for (let player in newState.wall) {\n    for (let row in newState.wall[player]) {\n      const rowColor = newState.wall[player][row];\n      newState.wall[player][row].every(el => el === rowColor);\n    }\n  }\n\n  return newState;\n}","map":{"version":3,"names":["fillRepos","calcPenalty","addArrays","finishRound","state","newState","isRoundOver","repos","every","el","emptyTileField","evaluateRows","evaluatePenalties","putBackStartingTile","calcFinalScores","player","rows","length","row","rowColor","isRowFull","column","wallPattern","findIndex","wall","lastTile","addScoreForLastTile","emptyRow","scoreForLastTile","directions","d","delta","hasNeighbor","positionOnWall","isPosOnWall","nColor","isPosEmpty","scores","rowLength","usedTiles","push","Array","fill","penalties","penalty","Math","max","startingTile","isGameOver"],"sources":["/home/lorenz/programming/azul_create_react_app/src/azul_lib/finishRound.js"],"sourcesContent":["import fillRepos from './fillRepos.js';\nimport calcPenalty from './calcPenalty.js'\nimport addArrays from '../js_utils/addArrays.js'\n\n\nexport default function finishRound(state) {\n\n\tlet newState = { ...state };\n\n    const isRoundOver = newState.repos.every(el => el.every(el => el===newState.emptyTileField));\n\n    if (isRoundOver) {\n        newState = evaluateRows(newState);\n        newState = evaluatePenalties(newState);\n        newState = fillRepos(newState);\n        newState = putBackStartingTile(newState);\n        newState = calcFinalScores(newState);\n        return newState\n    } else {\n        return state\n    }\n}\n\nfunction evaluateRows(state) {\n    /*\n    for full rows, this function:\n    1) moves one tile per row to wall\n    2) updates scores based on added wall tiles\n    3) empties rows\n    */\n\n\tlet newState = { ...state };\n\n    for (let player = 0; player < newState.rows.length; player++) {\n        for (let row = 0; row < newState.rows[player].length; row++) {\n            const rowColor = newState.rows[player][row][0];\n            const isRowFull = (\n                newState.rows[player][row].every(\n                    el => el===rowColor\n                ) && \n                rowColor!==newState.emptyTileField\n            );\n            if (isRowFull) {\n                const column = newState.wallPattern[row].findIndex(el => el===rowColor);\n                newState.wall[player][row][column] = rowColor;\n                const lastTile = [row, column];\n                newState = addScoreForLastTile(newState, player, lastTile);\n                newState = emptyRow(newState, player, row);\n            }\n        }\n    }\n\n\treturn newState\n}\n\nfunction addScoreForLastTile(state, player, lastTile) {\n\n\tconst newState = { ...state };\n\n    let scoreForLastTile = 1;\n\n    const directions = [\n        [\n            [1,0],//vertical\n            [-1,0]//vertical\n        ],\n        [\n            [0,1],//horizontal\n            [0,-1]//horizontal\n        ]\n    ];\n\n    for (let d in directions) {//vertically or horizontally\n        for (let delta of directions[d]) {//up or down / left or right\n            let hasNeighbor = true;\n            let positionOnWall = lastTile;\n            while (hasNeighbor) {\n                positionOnWall = addArrays(positionOnWall, delta);\n                const row = positionOnWall[0];\n                const column = positionOnWall[1];\n                const isPosOnWall = \n                    (row > -1) &&  \n                    (column > -1) && \n                    (row < state.nColor) && \n                    (column < state.nColor);\n                if(isPosOnWall) {\n                    const isPosEmpty = (newState.wall[player][row][column]===state.emptyTileField);\n                    if (isPosEmpty) {\n                        hasNeighbor = false;\n                    } else {\n                        scoreForLastTile++;\n                    }  \n                } else {\n                    hasNeighbor = false;\n                }\n            }\n        }\n    }\n    newState.scores[player] += scoreForLastTile;\n\n\treturn newState\n}\n\nfunction emptyRow(state, player, row) {\n\n\tconst newState = { ...state };\n\n    const rowLength = row + 1;\n    const rowColor = newState.rows[player][row][0];\n    newState.usedTiles.push(\n        ...Array(rowLength-1).fill(rowColor)//one tile is put on the wall\n    );\n\tnewState.rows[player][row] = Array(rowLength).fill(newState.emptyTileField);\n\n\treturn newState\n}\n\nfunction evaluatePenalties(state) {\n    /*\n    this function:\n    1) updates scores based on penalties\n    2) moves penalty tiles to usedTiles\n    */\n\n\tconst newState = { ...state };\n\n\tfor (let player in newState.penalties) {\n        \n        const penalty = calcPenalty(newState, player);\n        newState.scores[player] -= penalty;\n        newState.scores[player] = Math.max(//negative score is not allowed\n            0,\n            newState.scores[player]\n        );\n\n        newState.usedTiles.push(\n            ...newState.penalties[player]\n        );\n        newState.penalties[player] = [];\n    }\n\n\treturn newState\n}\n\nfunction putBackStartingTile(state) {\n\n\tconst newState = { ...state };\n\n\tnewState.startingTile = 'middle';\n\n\treturn newState\n}\n\nfunction calcFinalScores(state) {\n\n\tconst newState = { ...state };\n\n    //any player with full row? then calc final score and make alert for winner\n    const isGameOver = false;\n    for (let player in newState.wall) {\n        for (let row in newState.wall[player]) {\n            const rowColor = newState.wall[player][row];\n            newState.wall[player][row].every(el => el === rowColor);\n        }\n    }\n\n\treturn newState\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}