{"ast":null,"code":"import _toConsumableArray from\"/home/lorenz/programming/game_with_tiles/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import _createForOfIteratorHelper from\"/home/lorenz/programming/game_with_tiles/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";import _objectSpread from\"/home/lorenz/programming/game_with_tiles/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import fillRepos from'./fillRepos.js';import calcPenalty from'./calcPenalty.js';import addArrays from'../js_utils/addArrays.js';export default function finishRound(state){/* this function is called in putTilesIntoRow.js if all repos are empty*/var newState=_objectSpread({},state);newState=evaluateRows(newState);newState=evaluatePenalties(newState);var isGameOver=anyRowFull(newState);if(isGameOver){newState=addFinalScore(newState);newState.isGameOver=true;}else{newState=fillRepos(newState);newState=putBackStartingTile(newState);}return newState;}function evaluateRows(state){/*\n    for full rows, this function:\n    1) moves one tile per row to wall\n    2) updates scores based on added wall tiles\n    3) empties rows\n    */var newState=_objectSpread({},state);for(var player=0;player<newState.rows.length;player++){var _loop=function _loop(row){var rowColor=newState.rows[player][row][0];var isRowFull=newState.rows[player][row].every(function(el){return el===rowColor;})&&rowColor!==newState.emptyTileField;if(isRowFull){var column=newState.wallPattern[row].findIndex(function(el){return el===rowColor;});newState.wall[player][row][column]=rowColor;var lastTile=[row,column];newState=addScoreForLastTile(newState,player,lastTile);newState=emptyRow(newState,player,row);}};for(var row=0;row<newState.rows[player].length;row++){_loop(row);}}return newState;}function addScoreForLastTile(state,player,lastTile){var newState=_objectSpread({},state);var scoreForLastTile=1;var directions=[[[1,0],//vertical\n[-1,0]//vertical\n],[[0,1],//horizontal\n[0,-1]//horizontal\n]];for(var d in directions){//vertically or horizontally\nvar _iterator=_createForOfIteratorHelper(directions[d]),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var delta=_step.value;//up or down / left or right\nvar hasNeighbor=true;var positionOnWall=lastTile;while(hasNeighbor){positionOnWall=addArrays(positionOnWall,delta);var row=positionOnWall[0];var column=positionOnWall[1];var isPosOnWall=row>-1&&column>-1&&row<state.nColor&&column<state.nColor;if(isPosOnWall){var isPosEmpty=newState.wall[player][row][column]===state.emptyTileField;if(isPosEmpty){hasNeighbor=false;}else{scoreForLastTile++;}}else{hasNeighbor=false;}}}}catch(err){_iterator.e(err);}finally{_iterator.f();}}newState.scores[player]+=scoreForLastTile;return newState;}function emptyRow(state,player,row){var _newState$usedTiles;var newState=_objectSpread({},state);var rowLength=row+1;var rowColor=newState.rows[player][row][0];(_newState$usedTiles=newState.usedTiles).push.apply(_newState$usedTiles,_toConsumableArray(Array(rowLength-1).fill(rowColor)));newState.rows[player][row]=Array(rowLength).fill(newState.emptyTileField);return newState;}function evaluatePenalties(state){/*\n    this function:\n    1) updates scores based on penalties\n    2) moves penalty tiles to usedTiles\n    */var newState=_objectSpread({},state);for(var player in newState.penalties){var _newState$usedTiles2;var penalty=calcPenalty(newState,player);newState.scores[player]-=penalty;newState.scores[player]=Math.max(//negative score is not allowed\n0,newState.scores[player]);(_newState$usedTiles2=newState.usedTiles).push.apply(_newState$usedTiles2,_toConsumableArray(newState.penalties[player]));newState.penalties[player]=[];}return newState;}function putBackStartingTile(state){var newState=_objectSpread({},state);newState.startingTile='middle';return newState;}function anyRowFull(state){var newState=_objectSpread({},state);var isGameOver=false;for(var player in newState.wall){for(var row in newState.wall[player]){var isRowFull=newState.wall[player][row].every(function(el){return el!==newState.emptyTileField;});if(isRowFull){isGameOver=true;return isGameOver;}}}return isGameOver;}function addFinalScore(state){var newState=_objectSpread({},state);for(var player in newState.wall){var cumScore=0;for(var row in newState.wall[player]){var isRowFull=newState.wall[player][row].every(function(el){return el!==newState.emptyTileField;});if(isRowFull){cumScore+=2;}}var _loop2=function _loop2(column){var columnSum=newState.wall[player].reduce(function(acc,el){return acc+el[column];},0);var isColumnFull=columnSum===10;if(isColumnFull){cumScore+=7;}};for(var column in newState.wall[player]){_loop2(column);}var _loop3=function _loop3(color){var isColorFull=newState.wall[player].every(function(el){return el.includes(color);});if(isColorFull){cumScore+=10;}};for(var color in newState.wall[player]){_loop3(color);}newState.scores[player]+=cumScore;}return newState;}","map":{"version":3,"names":["fillRepos","calcPenalty","addArrays","finishRound","state","newState","evaluateRows","evaluatePenalties","isGameOver","anyRowFull","addFinalScore","putBackStartingTile","player","rows","length","row","rowColor","isRowFull","every","el","emptyTileField","column","wallPattern","findIndex","wall","lastTile","addScoreForLastTile","emptyRow","scoreForLastTile","directions","d","delta","hasNeighbor","positionOnWall","isPosOnWall","nColor","isPosEmpty","scores","rowLength","usedTiles","push","Array","fill","penalties","penalty","Math","max","startingTile","cumScore","columnSum","reduce","acc","isColumnFull","color","isColorFull","includes"],"sources":["/home/lorenz/programming/game_with_tiles/src/azul_lib/finishRound.js"],"sourcesContent":["import fillRepos from './fillRepos.js';\nimport calcPenalty from './calcPenalty.js'\nimport addArrays from '../js_utils/addArrays.js'\n\nexport default function finishRound(state) {\n    /* this function is called in putTilesIntoRow.js if all repos are empty*/\n\t\n    let newState = { ...state };\n\n    newState = evaluateRows(newState);\n    newState = evaluatePenalties(newState);\n    const isGameOver = anyRowFull(newState);\n    if (isGameOver) {\n        newState = addFinalScore(newState);\n        newState.isGameOver = true;\n    } else {\n        newState = fillRepos(newState);\n        newState = putBackStartingTile(newState);\n    }\n    \n    return newState\n}\n\nfunction evaluateRows(state) {\n    /*\n    for full rows, this function:\n    1) moves one tile per row to wall\n    2) updates scores based on added wall tiles\n    3) empties rows\n    */\n\n\tlet newState = { ...state };\n\n    for (let player = 0; player < newState.rows.length; player++) {\n        for (let row = 0; row < newState.rows[player].length; row++) {\n            const rowColor = newState.rows[player][row][0];\n            const isRowFull = (\n                newState.rows[player][row].every(\n                    el => el===rowColor\n                ) && \n                rowColor!==newState.emptyTileField\n            );\n            if (isRowFull) {\n                const column = newState.wallPattern[row].findIndex(el => el===rowColor);\n                newState.wall[player][row][column] = rowColor;\n                const lastTile = [row, column];\n                newState = addScoreForLastTile(newState, player, lastTile);\n                newState = emptyRow(newState, player, row);\n            }\n        }\n    }\n\n\treturn newState\n}\n\nfunction addScoreForLastTile(state, player, lastTile) {\n\n\tconst newState = { ...state };\n\n    let scoreForLastTile = 1;\n\n    const directions = [\n        [\n            [1,0],//vertical\n            [-1,0]//vertical\n        ],\n        [\n            [0,1],//horizontal\n            [0,-1]//horizontal\n        ]\n    ];\n\n    for (let d in directions) {//vertically or horizontally\n        for (let delta of directions[d]) {//up or down / left or right\n            let hasNeighbor = true;\n            let positionOnWall = lastTile;\n            while (hasNeighbor) {\n                positionOnWall = addArrays(positionOnWall, delta);\n                const row = positionOnWall[0];\n                const column = positionOnWall[1];\n                const isPosOnWall = \n                    (row > -1) &&  \n                    (column > -1) && \n                    (row < state.nColor) && \n                    (column < state.nColor);\n                if(isPosOnWall) {\n                    const isPosEmpty = (newState.wall[player][row][column]===state.emptyTileField);\n                    if (isPosEmpty) {\n                        hasNeighbor = false;\n                    } else {\n                        scoreForLastTile++;\n                    }  \n                } else {\n                    hasNeighbor = false;\n                }\n            }\n        }\n    }\n    newState.scores[player] += scoreForLastTile;\n\n\treturn newState\n}\n\nfunction emptyRow(state, player, row) {\n\n\tconst newState = { ...state };\n\n    const rowLength = row + 1;\n    const rowColor = newState.rows[player][row][0];\n    newState.usedTiles.push(\n        ...Array(rowLength-1).fill(rowColor)//one tile is put on the wall\n    );\n\tnewState.rows[player][row] = Array(rowLength).fill(newState.emptyTileField);\n\n\treturn newState\n}\n\nfunction evaluatePenalties(state) {\n    /*\n    this function:\n    1) updates scores based on penalties\n    2) moves penalty tiles to usedTiles\n    */\n\n\tconst newState = { ...state };\n\n\tfor (let player in newState.penalties) {\n        \n        const penalty = calcPenalty(newState, player);\n        newState.scores[player] -= penalty;\n        newState.scores[player] = Math.max(//negative score is not allowed\n            0,\n            newState.scores[player]\n        );\n\n        newState.usedTiles.push(\n            ...newState.penalties[player]\n        );\n        newState.penalties[player] = [];\n    }\n\n\treturn newState\n}\n\nfunction putBackStartingTile(state) {\n\n\tconst newState = { ...state };\n\n\tnewState.startingTile = 'middle';\n\n\treturn newState\n}\n\nfunction anyRowFull(state) {\n   \n\tlet newState = { ...state };\n\n    let isGameOver = false;\n    for (let player in newState.wall) {\n        for (let row in newState.wall[player]) {\n            const isRowFull = newState.wall[player][row].every(\n                el => el !== newState.emptyTileField\n            );\n            if (isRowFull) {\n                isGameOver = true;\n                return isGameOver            \n            }\n        }\n    }\n\n\treturn isGameOver\n}\n\nfunction addFinalScore(state) {\n\n    const newState = { ...state };\n    \n    for (let player in newState.wall) {\n        let cumScore = 0;\n        for (let row in newState.wall[player]) {\n            const isRowFull = newState.wall[player][row].every(\n                el => el !== newState.emptyTileField\n            );\n            if (isRowFull) {\n                cumScore += 2;\n            }\n        }\n        for (let column in newState.wall[player]) {\n            const columnSum = newState.wall[player].reduce(\n                (acc,el) => acc + el[column],\n                0\n            );\n            const isColumnFull = (columnSum === 10);\n            if (isColumnFull) {\n                cumScore += 7;\n            }\n        }\n        for (let color in newState.wall[player]) {\n            const isColorFull = newState.wall[player].every(\n                el => el.includes(color)\n            );\n            if (isColorFull) {\n                cumScore += 10;\n            }\n        }\n        newState.scores[player] += cumScore;\n    }\n\n    return newState\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}